import {
  DocumentType,
  getDiscriminatorModelForClass,
  Index,
  Pre,
  Prop,
} from "@typegoose/typegoose";
import { ObjectId } from "mongodb";
import { Currency, ProductType } from "../../enums";
import { ONE_DAY } from "../../utils/dateUtils";
import { DateRange, TimeRange } from "../commonTypes/DateRange.type";
import { Product, ProductModel } from "../_abstract/Product/Product.model";
import {
  IAutomatable,
  IAutomatorInfo,
} from "../_abstract/ProductAutomator/IAutomator.interface";
import {
  Capacity,
  CapacitySummary,
  capacityToUsageDetails,
} from "./Capacity.type";

export class ProductBookingAutomatorInfo implements IAutomatorInfo {
  constructor(input: {
    automatorId: ObjectId;
    basedDate: Date;
    index: number;
    timeRangeForUse: TimeRange;
    timeRangeForSale?: TimeRange;
  }) {
    for (const key in input) {
      if (Object.prototype.hasOwnProperty.call(input, key)) {
        const element = input[key];
        this[key] = element;
      }
    }
    const basedDateTime = input.basedDate.getTime();
    this.basedDate = new Date(basedDateTime - (basedDateTime % ONE_DAY));
    this.calculatedDate = new Date(
      this.basedDate.getTime() + ONE_DAY * input.index
    );
    this.hashCode = this.toHashCode();
  }

  @Prop({ type: () => ObjectId, required: true })
  automatorId!: ObjectId;

  @Prop({ required: true })
  index!: number;

  @Prop({ required: true })
  basedDate!: Date;

  @Prop({
    default(this: ProductBookingAutomatorInfo) {
      return new Date(this.basedDate.getTime() + ONE_DAY * this.index);
    },
  })
  calculatedDate!: Date;

  @Prop({ type: () => TimeRange, required: true })
  timeRangeForUse!: TimeRange;

  @Prop({ type: () => TimeRange })
  timeRangeForSale?: TimeRange;

  @Prop({
    default(this: ProductBookingAutomatorInfo) {
      return this.toHashCode();
    },
  })
  hashCode!: string;

  toHashCode() {
    return `${this.automatorId.toHexString()}_${this.calculatedDate.getTime()}_${this.timeRangeForUse.toString()}`;
  }
}

@Index(
  {
    "automatorInfo.hashCode": true,
  },
  {
    unique: true,
    sparse: true,
  }
)
@Pre("save", async function (this: DocumentType<ProductBooking>, next) {
  const capacity = this.capacityDetails;
  this.usageDetails = capacity.map(capacityToUsageDetails);
  next();
})
export class ProductBooking extends Product implements IAutomatable {
  get typeSet() {
    return ProductType.BOOKING;
  }

  @Prop()
  disabled?: boolean;

  @Prop({ type: () => DateRange })
  dateRangeForSale?: DateRange;

  @Prop({ type: () => DateRange, _id: false })
  dateRangeForUse?: DateRange;

  @Prop({ required: true, default: Currency.KRW })
  currency: Currency = Currency.KRW;

  @Prop({ required: true })
  price!: number;

  @Prop({ required: true })
  capacity!: number;

  @Prop()
  capacityPick?: number;

  @Prop({ type: () => [Capacity] })
  capacityDetails: Capacity[] = [];

  @Prop({
    type: () => [CapacitySummary],
    _id: false,
    default(this: DocumentType<ProductBooking>) {
      return this.capacityDetails.map(capacityToUsageDetails);
    },
  })
  usageDetails!: CapacitySummary[];

  // automator로부터 받은 정보. unique 값을 판별하기 위함임.
  @Prop({
    type: () => ProductBookingAutomatorInfo,
    required: false,
    _id: false,
  })
  automatorInfo?: ProductBookingAutomatorInfo;

  isAutogenerated() {
    return !!this.automatorInfo;
  }
}

export const ProductBookingModel = getDiscriminatorModelForClass(
  ProductModel,
  ProductBooking
);
